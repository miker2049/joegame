{"version":3,"sources":["../../src/actions/speakString.ts"],"names":["str","char","speakFunc","speed","words","split","wlength","length","i","syllable","randArr","randArrayAndSum","numbers","j","delay","globalDefaults","talkingSpeed","scene","cameras","main","worldView","contains","x","y","vAndp","getVolAndPanFromDistance","centerX","width","inst","buff","undefined","rate","vol","pan","sum","arr","push","Math","random","reduce","pr","val","clump","n","out","playerX","charX","cameraWidth","difference","mod","abs"],"mappings":"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","sourcesContent":["import 'phaser'\nimport { chunk } from 'lodash'\nimport { ILevelComponents } from '../ILevel'\nimport timeout from '../utils/awaitTimeout'\nimport globalDefaults from '../defaults'\nimport syllableCount from '../utils/syllableCount'\nimport { ITalkingPlayConfig } from '../sound/synths/Talking'\nimport hashToArr from '../utils/hashToArr'\nexport default async function(str: string, char: { x: number, y: number, scene: Phaser.Scene }, speakFunc: (config: ITalkingPlayConfig) => void, speed?: number): Promise<void> {\n    // if (!(Phaser.Geom.Rectangle.ContainsPoint(char.scene.cameras.main.getBounds(), new Phaser.Geom.Point(char.x, char.y)))) return\n\n    const words = str.split(' ')\n    const wlength = words.length\n    // const ttime = ((speed ?? globalDefaults.talkingSpeed) * str.replace(' ', '').length) +\n    //     ((str.match(/\\s/g)?.length ?? 0) * (globalDefaults.talkingSpeed * 1.7))\n    for (let i = 0; i < wlength; i++) {\n        // console.log(hashCode(words[i]))\n        const syllable = syllableCount(words[i])\n        const randArr = randArrayAndSum(syllable)\n        // need two indexes for each syllable, for vowel (buff) and rate (pitch)\n        // TODO remove lodash dependency!!!\n        const numbers = chunk(hashToArr(words[i], syllable * 2), 2)\n\n        for (let j = 0; j < randArr[0].length; j++) {\n            const delay = (randArr[0][j] / randArr[1]) * (words[i].length * globalDefaults.talkingSpeed)\n            if (char.scene.cameras.main.worldView.contains(char.x, char.y) == true) {\n                const vAndp = getVolAndPanFromDistance(char.scene.cameras.main.worldView.centerX, char.x, char.scene.cameras.main.worldView.width)\n                speakFunc({ inst: 'talking', buff: numbers[j][0] ?? undefined, rate: numbers[j][1] ?? undefined, vol: vAndp[0], pan: vAndp[1] })\n            }\n            await timeout(delay)\n        }\n        await timeout(globalDefaults.talkingSpeed * 1.7)\n    }\n    return\n}\n\nfunction randArrayAndSum(length: number): [number[], number] {\n    let sum = 0\n    let arr = []\n    for (let i = 0; i < length; i++) {\n        arr.push(Math.random())\n    }\n    return [arr, arr.reduce((pr, val) => pr + val)]\n}\n\nfunction clump(arr: any[], n: number) {\n    if (arr.length < n) return [arr]\n    let i = 0, out = []\n\n}\n\n\ntype volAndPan = [vol: number, pan: number]\nfunction getVolAndPanFromDistance(playerX: number, charX: number, cameraWidth: number): volAndPan {\n    const difference = charX - playerX\n    const mod = difference > 0 ? -1 : 1\n    const pan = difference / (cameraWidth / 2)\n    return [Math.abs(pan), pan]\n}\n"],"file":"speakString.js"}