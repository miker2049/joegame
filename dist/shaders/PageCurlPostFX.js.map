{"version":3,"sources":["../../src/shaders/PageCurlPostFX.ts"],"names":["fragShader","PageCurlPostFX","game","name","resizeMode","toRatio","radius","from","Phaser","Math","Vector2","to","setTexture","mode","texture","phaserTexture","textures","getFrame","width","height","targetTexture","glTexture","undefined","set1i","set1f","x","y","set","value","renderTarget","w","h","set2f","bindTexture","bindAndDraw","Renderer","WebGL","Pipelines","PostFXPipeline"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       laserdog\r\n * @copyright    2021 Photon Storm Ltd.\r\n */\r\n\r\nimport Phaser from 'phaser';\r\n\r\nconst fragShader = `\r\n#define SHADER_NAME PAGE_CURL_FS\r\n\r\nprecision mediump float;\r\n\r\nuniform sampler2D uMainSampler;\r\nuniform sampler2D uMainSampler2;\r\n\r\nuniform int resizeMode;\r\nuniform vec2 resolution;\r\nuniform vec2 from;\r\nuniform vec2 to;\r\nuniform float radius;\r\nuniform float fromRatio;\r\nuniform float toRatio;\r\n\r\nvarying vec2 outFragCoord;\r\n\r\n#define pi 3.14159265359\r\n\r\nvec4 getFromColor (vec2 uv)\r\n{\r\n    return texture2D(uMainSampler, uv);\r\n}\r\n\r\nvec4 getToColor (vec2 uv)\r\n{\r\n    if (resizeMode == 2)\r\n    {\r\n        //  cover\r\n        return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(min(fromRatio / toRatio, 1.0), min((toRatio / fromRatio), 1.0)));\r\n    }\r\n    else if (resizeMode == 1)\r\n    {\r\n        //  contain\r\n        return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(max(fromRatio / toRatio, 1.0), max((toRatio / fromRatio), 1.0)));\r\n    }\r\n    else\r\n    {\r\n        //  stretch\r\n        return texture2D(uMainSampler2, vec2(uv.x, 1.0 - uv.y));\r\n    }\r\n}\r\n\r\nvec4 transition (vec2 p)\r\n{\r\n    float aspect = fromRatio;\r\n\r\n    vec2 uv = p * vec2(aspect, 1.0) / resolution.xy;\r\n    vec2 mouse = to * vec2(aspect, 1.0) / resolution.xy;\r\n    vec2 mouseDir = normalize(abs(from) - to);\r\n    vec2 origin = clamp(mouse - mouseDir * mouse.x / mouseDir.x, 0.0, 1.0);\r\n    \r\n    float mouseDist = clamp(length(mouse - origin) \r\n        + (aspect - (abs(from.x) / resolution.x) * aspect) / mouseDir.x, 0.0, aspect / mouseDir.x);\r\n    \r\n    if (mouseDir.x < 0.0)\r\n    {\r\n        mouseDist = distance(mouse, origin);\r\n    }\r\n\r\n    float proj = dot(uv - origin, mouseDir);\r\n    float dist = proj - mouseDist;\r\n    \r\n    vec2 linePoint = uv - dist * mouseDir;\r\n    vec4 color;\r\n\r\n    if (dist > radius) \r\n    {\r\n        color = getToColor(uv * vec2(1.0 / aspect, 1.0));\r\n        color.rgb *= pow(clamp(dist - radius, 0.0, 1.0) * 1.5, 0.2);\r\n    }\r\n    else if (dist >= 0.0)\r\n    {\r\n        //  Map to cylinder point\r\n        float theta = asin(dist / radius);\r\n        vec2 p2 = linePoint + mouseDir * (pi - theta) * radius;\r\n        vec2 p1 = linePoint + mouseDir * theta * radius;\r\n        uv = (p2.x <= aspect && p2.y <= 1.0 && p2.x > 0.0 && p2.y > 0.0) ? p2 : p1;\r\n\r\n        color = getFromColor(uv * vec2(1.0 / aspect, 1.0));\r\n        color.rgb *= pow(clamp((radius - dist) / radius, 0.0, 1.0), 0.2);\r\n    }\r\n    else \r\n    {\r\n        vec2 p = linePoint + mouseDir * (abs(dist) + pi * radius);\r\n\r\n        uv = (p.x <= aspect && p.y <= 1.0 && p.x > 0.0 && p.y > 0.0) ? p : uv;\r\n\r\n        color = getFromColor(uv * vec2(1.0 / aspect, 1.0));\r\n    }\r\n\r\n    return color;\r\n}\r\n    \r\nvoid main ()\r\n{\r\n    gl_FragColor = transition(gl_FragCoord.xy);\r\n}\r\n`;\r\n\r\nexport class PageCurlPostFX extends Phaser.Renderer.WebGL.Pipelines.PostFXPipeline\r\n{\r\n    /**\r\n     * The WebGL Texture being transitioned to.\r\n     *\r\n     * @type {WebGLTexture}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    targetTexture: WebGLTexture;\r\n\r\n    /**\r\n     * The resize mode to be used for the target texture.\r\n     * \r\n     * Can be either 0, 1 or 2, for stretch, contain and cover modes respectively.\r\n     * \r\n     * The default is 'contain'.\r\n     * \r\n     * Set via the `setResizeMode` method.\r\n     *\r\n     * @type {number}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    resizeMode: number;\r\n\r\n    /**\r\n     * The ratio of the target texture (width / height).\r\n     * \r\n     * This is set automatically in the `setTexture` method.\r\n     *\r\n     * @type {number}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    toRatio: number;\r\n\r\n    /**\r\n     * The radius of the curl.\r\n     * \r\n     * Use very low values. The default is 0.1.\r\n     * \r\n     * @type {number}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    radius: number;\r\n\r\n    /**\r\n     * The position the effect runs from.\r\n     * \r\n     * See also the `setFrom` method.\r\n     * \r\n     * @type {Phaser.Math.Vector2}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    from: Phaser.Math.Vector2;\r\n\r\n    /**\r\n     * The position the effect runs to.\r\n     * \r\n     * See also the `setTo` method.\r\n     * \r\n     * @type {Phaser.Math.Vector2}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    to: Phaser.Math.Vector2;\r\n\r\n    /**\r\n     * The Page Curl FX allows you to create a classic 'page curl' motion\r\n     * between two sources. The curl proceeds from either the top-left or\r\n     * top-right of the source. You can control the position vectors\r\n     * independantly, as well as the radius of the curl.\r\n     * \r\n     * The source image comes from the Game Object to which the FX is applied,\r\n     * which can be any Game Object that supports post pipelines, such as a\r\n     * Sprite, Rope or Layer. You can also transition Cameras and even entire\r\n     * Scenes. Please see the examples and class docs for further details.\r\n     * \r\n     * @param {Phaser.Game} game\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    constructor (game: Phaser.Game)\r\n    {\r\n        super({\r\n            game,\r\n            name: 'PageCurlPostFX',\r\n            fragShader\r\n        });\r\n\r\n        this.resizeMode = 0;\r\n        this.toRatio = 0;\r\n\r\n        this.radius = 0.1;\r\n        this.from = new Phaser.Math.Vector2();\r\n        this.to = new Phaser.Math.Vector2();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    onBoot (): void\r\n    {\r\n        this.setTexture();\r\n    }\r\n\r\n    /**\r\n     * Set the resize mode of the target texture.\r\n     * \r\n     * Can be either:\r\n     * \r\n     * 0 - Stretch. The target texture is stretched to the size of the source texture.\r\n     * 1 - Contain. The target texture is resized to fit the source texture. This is the default.\r\n     * 2 - Cover. The target texture is resized to cover the source texture.\r\n     * \r\n     * If the source and target textures are the same size, then use a resize mode of zero\r\n     * for speed.\r\n     *\r\n     * @param {number} [mode=1] - The Resize Mode. Either 0, 1 or 2.\r\n     * @returns {this}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    setResizeMode (mode: number = 1): this\r\n    {\r\n        this.resizeMode = mode;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the texture to be transitioned to.\r\n     * \r\n     * The texture must be already loaded and available from the Texture Manager.\r\n     * \r\n     * You can optionally also set the resize mode. This can be either:\r\n     * \r\n     * 0 - Stretch. The target texture is stretched to the size of the source texture.\r\n     * 1 - Contain. The target texture is resized to fit the source texture. This is the default.\r\n     * 2 - Cover. The target texture is resized to cover the source texture.\r\n     * \r\n     * If the source and target textures are the same size, then use a resize mode of zero\r\n     * for speed.\r\n     *\r\n     * @param {string} [texture='__DEFAULT'] - The key of the texture to use.\r\n     * @param {number} [mode] - The Resize Mode. Either 0, 1 or 2.\r\n     * @returns {this}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    setTexture (texture: string = '__DEFAULT', resizeMode?: number): this\r\n    {\r\n        let phaserTexture = this.game.textures.getFrame(texture);\r\n\r\n        if (!phaserTexture)\r\n        {\r\n            phaserTexture = this.game.textures.getFrame('__DEFAULT');\r\n        }\r\n\r\n        this.toRatio = phaserTexture.width / phaserTexture.height;\r\n\r\n        this.targetTexture = phaserTexture.glTexture;\r\n\r\n        if (resizeMode !== undefined)\r\n        {\r\n            this.resizeMode = resizeMode;\r\n        }\r\n\r\n        this.set1i('uMainSampler2', 1);\r\n        this.set1f('toRatio', this.toRatio);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the position the effect should start from.\r\n     * \r\n     * The values are given in pixels and should typically be restricted\r\n     * to the range of the texture size the effect is running on.\r\n     * \r\n     * @param {number} x - The x position.\r\n     * @param {number} y - The y position.\r\n     * @returns {this}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    setFrom (x: number, y: number): this\r\n    {\r\n        this.from.set(x, y);\r\n        \r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the position the effect should run to.\r\n     * \r\n     * The values are given in pixels and should typically be restricted\r\n     * to the range of the texture size the effect is running on.\r\n     * \r\n     * @param {number} x - The x position.\r\n     * @param {number} y - The y position.\r\n     * @returns {this}\r\n     * @memberof PageCurlPostFX\r\n     */\r\n    setTo (x: number, y: number): this\r\n    {\r\n        this.to.set(x, y);\r\n        \r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the radius of the curl effect.\r\n     * \r\n     * Should be a small value. The defaul is 0.1.\r\n     * \r\n     * @param {number} [value=0.1] - The radius.\r\n     * @returns {this}\r\n     * @memberof PageCurlPostFX\r\n    */\r\n   setRadius (value: number = 0.1): this\r\n   {\r\n       this.radius = value;\r\n       \r\n       return this;\r\n   }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    onPreRender (): void\r\n    {\r\n        this.set1i('resizeMode', this.resizeMode);\r\n        this.set1f('radius', this.radius);\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    onDraw (renderTarget: Phaser.Renderer.WebGL.RenderTarget): void\r\n    {\r\n        const w = renderTarget.width;\r\n        const h = renderTarget.height;\r\n\r\n        this.set1f('fromRatio', w / h);\r\n        this.set2f('resolution', w, h);\r\n        this.set2f('from', this.from.x, h - this.from.y);\r\n        this.set2f('to', this.to.x, h - this.to.y);\r\n\r\n        this.bindTexture(this.targetTexture, 1);\r\n\r\n        this.bindAndDraw(renderTarget);\r\n    }\r\n}\r\n"],"file":"PageCurlPostFX.js"}