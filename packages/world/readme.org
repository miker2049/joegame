#+title: Readme

* joegame world generator
* api
* notes
** etc
*** Main Concepts
In [[id:b8f0a328-ebd7-4142-86f3-a278e6d5b6de][joegame]], the overall structure of the world is divided into certain main concepts.
**** area
The toplevel world of joegame is a [[id:f7daa8ab-3c30-4a8a-9065-6fc16af4c9c7][signal]], or collection of [[id:aff02f4b-c722-43cc-a3fa-60ac8f9ad2b5][merged signals]], which produce a list of areas for each coordinate, lowest depth to highest.

Every area has a name, a color to represent it in the world map, and its own signal, which produces a list of placed terrains given a coordinate, running from terr at the lowest depth to the highest.

Each area is also a 4x4 chunk of terrain /spots/.  They are not 4x4 chunks of terrains, because every spot is a list of terrains
**** terrain
A terrain has a name, color for the map, and a set of particles and their likelihood.

A given absolute coordinate will have an associated list of terrains a "terrain spot", which represent terrains at low to high/ground-level depth.

***** querying
To get a certain terrain spot within an area spot, you ask for some division (0.00,0.25,0.50,0.75) is used like so for an absolute coordinate: get_terrain(3.2,100.2), get_terrain(2.00, 2000.25).

**** tiles
A given terrain on a given depth level corresponds to 4x4 placed tiles, but for every such chunk, 4 terrains need to be queried for. Chunks are placed along each point where four terrains meet on a given level. Using the collective values of the four terrains a given quad is placed. Each terrain is treated separately, so the four terrains asked about are always either "terrain" or "not-terrain"
***** quad
A specific 4x4 arrangement of tiles, typically responding to a wang tile, and placed by checking terrains.

***** wang set
A wang set is a set of 16 quads that can be used as wang tiles.
***** tileset
An actual png file that has certain amount of tiles, used to make the quads of a wang set.
**** particles
A terrain is composed of particles.  Particles have a color-range and a name.
**** requesting a map
A map is 128x128 tiles, or 8x8 areas, where 1 area is 4 terrains, and each terrain is 4 tiles. 16 tiles per area.

The main function to retrieve a map takes simple indexes and multiplies by 128.

First a 8x8 grid of area lists are retrieved

*** Areas
#+name: joegame-area
| name                  | color   |
|-----------------------+---------|
| depths                | #313e49 |
| trench                | #5c758a |
| ocean                 | #B7C4CF |
| shore                 | #e0b483 |
| late-shore            | #c69763 |
| coastal               | #c6ad74 |
| grass-and-sand        | #839450 |
| rocky-sand            | #B18E68 |
| desert                | #ffffd3 |
| desert-graveyard      | #faa06b |
| dead-forest           | #f4c992 |
| old-pavement-desert   | #b89a74 |
| boulder-meadow-desert | #96794d |
| water-desert          | #c5e9bd |
| field                 | #33590e |
| old-pavement-field    | #8f8f51 |
| forest                | #293b09 |
| forest-magic          | #2e4114 |
| water-forest          | #2e352e |
| old-pavement-forest   | #444353 |
*** start
There are things called particles.
#+begin_quote
Then follows this, that nature brew up each thing again into its own first-bodies, nor does she destroy resolved ought into nothing. For if anything were mortal in all its parts, each thing would on a sudden be snatched from our eyes, and pass away.
#+end_quote


**** Particles
#+name: joegame-particles
| name                    | color 1 | color 2 | base wang mask | variations |
|-------------------------+---------+---------+----------------+------------|
| depths-drop             | #313e49 | #313e49 | smooth         | full       |
| depths-drop             | #313e49 | #313e49 | smooth         | full       |
| depths-drop             | #313e49 | #313e49 | smooth         | full       |
| trench-drop             | #5c758a | #5c758a | smooth         | full       |
| ocean-drop              | #B7C4CF | #B7C4CF | smooth         | full       |
| lake-drop               | #4AA0DF | #4AA0DF | smooth         | full       |
| grass-blade             | #1A9C4F | #32D083 | terrain        | all        |
| dead-grass-blade        | #897F38 | #B7AB55 | terrain        | all        |
| dirt-speck              | #967054 | #9F785A | smooth         | all        |
| rock-speck              | #464646 | #BFBFBF | terrain        | sparse     |
| gem                     | #0055B6 | #003A9E | terrain        | sparse     |
| quartz                  | #74453B | #BE9C92 | terrain        | sparse     |
| clay                    | #905932 | #905932 | smooth         | all        |
| stone                   | #9DA8A9 | #ADB8B9 | smooth         | all        |
| glass                   | #A8B77E | #A8B77E | terrain        | sparse     |
| sand                    | #E5BEA6 | #ECD0B8 | smooth         | all        |
| wet-sand                | #DBAB69 | #DAAC70 | smooth         | all        |
| pine-needle             | #7A3703 | #7B4602 | terrain        | sparse     |
| piece-of-plastic-blue   | #0078F8 | #007BF9 | terrain        | sparse     |
| piece-of-plastic-red    | #B51800 | #941B19 | terrain        | sparse     |
| piece-of-plastic-yellow | #AE9D11 | #C5B81D | terrain        | sparse     |
| bark                    | #5C3624 | #AE785E | terrain        | sparse     |

#+begin_src lisp :var jp=joegame-particles :results file :file "particles.data.lisp"

  (print
   (mapcar #'(lambda (it)
               (list
                :name (car it)
                :c1 (cadr it)
                :c2 (caddr it)
                ;; :c1(parse-integer (remove #\# (cadr it)) :radix 16)
                ;; :c2(parse-integer (remove #\# (caddr it)) :radix 16)
                :mask (cadddr it)
                :variations (nth 4 it)))
           jp))
#+end_src

#+RESULTS:
[[file:particles.data.lisp]]


*** Generating tile/wang images
**** terrain full generation
***** mask terrain
#+begin_src bash :shebang "#!/usr/bin/env bash" :tangle gen_terr
# Set default shadow strength
input_path="test.png"
mask_path="mask.png"
output_path="out.png"
strength="30x1+1+1"
bevel_color="pink"
bevel=0

# Function to print help message
print_help() {
  echo "Usage: gen_terr [OPTIONS]"
  echo ""
  echo "Generate terrain for wang masks from an image."
  echo ""
  echo "Options:"
  echo "  -h Show this help message and exit"
  echo "  -s Set shadow strength (default: 30x1+1+1)"
  echo "  -b enable bevel"
  echo "  -c set bevel color (e.g. 'pink')"
  echo "  -i The input 'terrain' file"
  echo "  -m The mask"
  echo "  -o output path"
}

blob() {
  local out=$1
  local size=$2
  magick -size 96x96 xc:  -channel G +noise Uniform \
      -virtual-pixel Tile -blur 0x$size -auto-level \
      -separate +channel static.png
  magick  static.png -ordered-dither threshold,2  $out
  rm -f static.png
}

add_noise() {
  local inn=$1
  local out=$2
  magick -size 96x96 xc:none -seed 1000 +noise random \
      -channel green -separate +channel -threshold 94% -transparent white noise.png
  # magick noise.png $out
  magick  noise.png $inn \
      -compose Dst_Over -composite $out
}

# Function to generate Wang Mask Tiles
generate_tiles() {
  local img=$1
  local outprefix=$2
  mkdir -p wang-tiles
  magick "$img" +gravity -crop 16x16 +repage $(printf "%s_%%d.png" $outprefix)
}

# Function to generate terrain tiles
gen_terr_tiles() {
  local dst=$1
  mask=$2
  local out=$3
  echo $dst
  magick $1 \( $2 -transparent black \) -compose Dst_In -alpha Set -composite $3

  if [[ $bevel == 1 ]]; then
      if identify -format '%[opaque]' $3 | grep -q 'False'; then
          magick $3 \( +clone -morphology Edge Diamond -fill $bevel_color -colorize 100 -transparent white \) -layers merge $3
      fi
  fi
  magick $3 -transparent white $3
  magick $3 \( +clone -background black -shadow $strength \) \
      -background none -compose Dst_Over -flatten $3
}

# Function to merge tiles
merge_tiles() {
    local tilesprefix=$1
    local out=$2
    local files=""
    for i in {0..35}; do files="$files $(printf "%s_%d.png" $tilesprefix $i)"; done;
    magick montage $files -background none -geometry 16x16+0+0 "$out"
}

# main function to generate terrains
gen_terr() {
    local image=$1
    local wang=$2
    local out=$3
    local outdir=$(mktemp -d)
    generate_tiles $image $(printf "%s%s" $outdir "/itile" ) &\
        generate_tiles $wang $(printf "%s%s" $outdir "/wtile" )
        wait
        for i in {0..35}; do gen_terr_tiles $(printf "%s%s_%d.png" $outdir "/itile" $i) \
            $(printf "%s%s_%d.png" $outdir "/wtile" $i) \
            $(printf "%s%s_%d.png" $outdir "/ftile" $i) &
        done
        wait
        merge_tiles $(printf "%s%s" $outdir "/ftile") $out
        rm -rf $outdir
}

# Parse arguments

while getopts ":hbs:c:o:m:i:" opt; do
  case ${opt} in
    h )
      print_help
      exit 0
      ;;
    s )
      strength=$OPTARG
      ;;
    b )
      bevel=1
      ;;
    c )
      bevel_color=$OPTARG
      ;;
    i )
      input_path=$OPTARG
      ;;
    o )
      output_path=$OPTARG
      ;;
    m )
      mask_path=$OPTARG
      ;;
    \? )
      echo "Error: Invalid option -$OPTARG"
      exit 1
      ;;
  esac
done
gen_terr $input_path $mask_path $output_path
# add_noise "$1" "$2"
#+end_src

**** add noise
#+begin_src bash :shebang "#!/usr/bin/env bash" :tangle add_noise

blob() {
  local out=$1
  local size=$2
  magick -size 96x96 xc:  -channel G +noise Uniform \
      -virtual-pixel Tile -blur 0x$size -auto-level \
      -separate +channel static.png
  magick  static.png -ordered-dither threshold,2  $out
  rm -f static.png
}

add_noise() {
  local inn=$1
  local amount=$2
  local out=$3
  local seed=$4

  # if seed is not provided, get a random value
  if [ -z "$seed" ]
  then
    seed=$RANDOM
    echo $seed
  fi

  magick -size 96x96 \( xc:none -seed $seed +noise random \
      -channel green -separate +channel -threshold "${amount}%" \) $inn \
      -compose Minus_Dst -composite $out
}

# Display usage message if not enough args or -h is supplied
if [ $# -lt 3 ] || [ "$1" = "-h" ]; then
  echo "Usage: $0 infile amount outputfile [seed]"
  echo "infile: input file name"
  echo "amount: noise amount"
  echo "outputfile: output file name"
  echo "seed: (optional) seed for random noise"
else
  add_noise $1 $2 $3 $4
fi
#+end_src
***** create noise series
#+begin_src bash :shebang "#!/usr/bin/env bash" :tangle create_noise_series
input=$1
seed=$2
basename="${input%.*}"
./add_noise $input 5 "${basename}-50.png" $seed
./add_noise $input 99.7 "${basename}-999.png" $seed
for idx in $(seq 100 100 900); do ./add_noise $input $(($idx/10)) "${basename}-${idx}.png" $seed; done
echo $basename
#+end_src

run that..
#+begin_src bash :var input="wang-masks/terr_wang-mask.png" seed=420
./create_noise_series $input $seed
#+end_src

#+RESULTS:
: wang-masks/terr_wang-mask

*** Generate labeled preview
#+begin_src bash :shebang "#!/usr/bin/env -S bash" :tangle label_tile
# create temporary directory
mkdir -p temp
font=/nix/store/bhq1mhgy0vwlvqi482g82vzkw4wldb89-iosevka-23.0.0/share/fonts/truetype/iosevka-regular.ttf
# loop over all images in the current directory
for img in ./terr-images/*.png; do
    # extract the filename without the extension
    filename=$(basename "$img" .png)
    # use ImageMagick to annotate the image with its filename
    convert "$img" -size 320x50 -font $font label:$filename -append \
        "temp/$(basename $img)"

done
# stitch annotated images together
magick montage temp/*.png -tile 6x terrains.png

# clean up temporary directory
rm -r temp
#+end_src
*** terrain set
#+begin_src lisp :package worldconf :results value table
(defun terrain-set-to-org-table (ts)
  (append
   nil
    ;; (list "name" "id" "color" "margin" "spacing" "imagepath")
    (mapcar #'(lambda (item)
                (let* ((item* (cdr item))
                        (tileset (getf item* :tileset)))
                    (list
                    (getf item* :name)
                    (getf item* :id)
                    (getf item* :priority)
                    (getf item* :wang-tiles)
                    (format nil "#~6,'0x"
                      (getf item* :color))
                    (tiledmap:margin tileset)
                    (tiledmap:spacing tileset)
                    (format nil "~a"
                      (tiledmap:image tileset)))))
            ts)))
    (terrain-set-to-org-table *terrain-set*)

#+end_src

#+RESULTS:
| deep-underwater |  0 |     0 | :TERRAIN       | #B7C4CF | 0 | 0 | /home/mik/joegame/assets/images/terr_trench.png      |
| ocean           |  1 |  1000 | :THICK-TERRAIN | #B7C4CF | 0 | 0 | /home/mik/joegame/assets/images/terr_ocean.png       |
| algea-ocean     |  2 |  2000 | :THICK-TERRAIN | #B7C4CF | 0 | 0 | /home/mik/joegame/assets/images/terr_water.png       |
| clay2           |  3 |  3000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2.png                             |
| terr_clay2_50   |  4 |  4000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_50.png                          |
| terr_clay2_100  |  5 |  5000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_100.png                         |
| terr_clay2_200  |  6 |  6000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_200.png                         |
| terr_clay2_300  |  7 |  7000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_300.png                         |
| terr_clay2_400  |  8 |  8000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_400.png                         |
| terr_clay2_500  |  9 |  9000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_500.png                         |
| terr_clay2_600  | 10 | 10000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_600.png                         |
| terr_clay2_700  | 11 | 11000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_700.png                         |
| terr_clay2_800  | 12 | 12000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_800.png                         |
| terr_clay2_900  | 13 | 13000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_900.png                         |
| terr_clay2_999  | 14 | 14000 | :TERRAIN       | #A9612D | 0 | 0 | generated_terr_clay2_999.png                         |
| clay            | 15 | 15000 | :TERRAIN       | #C38154 | 0 | 0 | /home/mik/joegame/assets/images/terr_clay.png        |
| simple-dirt     | 16 | 16000 | :TERRAIN       | #007E76 | 0 | 0 | /home/mik/joegame/assets/images/terr_dirt.png        |
| dirt            | 17 | 17000 | :TERRAIN       | #007E76 | 0 | 0 | /home/mik/joegame/assets/images/terr_dirt.png        |
| grass-patches   | 18 | 18000 | :TERRAIN       | #A0D8B3 | 0 | 0 | /home/mik/joegame/assets/images/terr_grass_patch.png |
| grass           | 19 | 19000 | :TERRAIN       | #A0D8B3 | 0 | 0 | /home/mik/joegame/assets/images/terr_grass.png       |
| deep-grass      | 20 | 20000 | :TERRAIN       | #A2A378 | 0 | 0 | /home/mik/joegame/assets/images/terr_grass.png       |
| sand            | 21 | 21000 | :TERRAIN       | #EEE3CB | 0 | 0 | /home/mik/joegame/assets/images/terr_sand.png        |
| hard-sand       | 22 | 22000 | :TERRAIN       | #D7C0AE | 0 | 0 | /home/mik/joegame/assets/images/terr_sand2.png       |
| stone           | 23 | 23000 | :TERRAIN       | #D6E8DB | 0 | 0 | /home/mik/joegame/assets/images/terr_sand.png        |
| cliff           | 24 | 24000 | :TERRAIN       | #000000 | 0 | 0 | /home/mik/joegame/assets/images/terr_sand.png        |
| stone           | 25 | 25000 | :TERRAIN       | #F6F1F1 | 0 | 0 | /home/mik/joegame/assets/images/terr_cobble.png      |
| ice             | 26 | 26000 | :TERRAIN       | #AFD3E2 | 0 | 0 | /home/mik/joegame/assets/images/terr_ice.png         |
| lake            | 27 | 27000 | :THICK-TERRAIN | #AFD3E2 | 0 | 0 | /home/mik/joegame/assets/images/terr_water.png       |
*** generating tiles
**** definitions
When we talk about tiles, we reference specific square sections of an actual image file.  A tileset is an image file with some extra data around it: tile height, tile width, margin, and spacing, where margin is the amount of pixels that make up the widths and heights of borders around the image, and spacing is the amount of pixels between the tiles. Each map (tiled json file), contains an array of tilesets.

In creating world stuff, the images used in tilesets are expected to conform to a certain wang-template.  A wang-template is just a certain map with one tileset that renders a grid of 16 wang quads (really, a wang /tile/, but thats too confusing). A wang quad is some grid of tiles, historically a 4x4 grid, and the full set of 16 make up all possible combinations of corners filled or unfilled.

*1:*
00
00

*2:*
01
00

*3:*
00
01

*4:*
01
01
 ...
*16:*
11
11

The main way to assure a tileset image can work with a wang-template is with a wang-terr-mask. We say terr mask because what we have been talking about this whole time is /terrains/, not /objects/.
**** the problem
The problem today (<2023-10-24 Tue>), is making the actual image stuff.  Masks already work well, but what if we want to create more variation? Well we can noise reduce masks, that is, randomly transform more and more pixels to black, creating a fading if these are combined in the right way.  But what if I wanted to make more complicated noise in the masks, but make sure they still work in the wang template?

If we look back at the wang-template, we see not only a template, but a set of constraints.  That is, each wang quad authorizes some set of tiles as compatible.  So,
*** db
**** db schema
#+begin_src sqlite :db db.db
CREATE TABLE IF NOT EXISTS images (
id INTEGER,
name TEXT NOT NULL,
data BLOB,
hash TEXT UNIQUE,
PRIMARY KEY(id AUTOINCREMENT));

CREATE TABLE IF NOT EXISTS sources (
id INTEGER,
name TEXT NOT NULL,
website TEXT,
PRIMARY KEY(id AUTOINCREMENT));

CREATE TABLE IF NOT EXISTS imagesmeta (
id INTEGER REFERENCES images(id) UNIQUE,
source INTEGER REFERENCES sources(id),
width INTEGER,
height INTEGER,
framewidth INTEGER,
frameheight INTEGER,
columns INTEGER,
tilecount INTEGER,
spacing INTEGER,
margin INTEGER);

CREATE TABLE IF NOT EXISTS objects (
id INTEGER,
image INTEGER REFERENCES images(id),
name text NOt NULL,
tiles JSON,
tilesWidth INTEGER,
PRIMARY KEY(id AUTOINCREMENT));


#+end_src

#+RESULTS:
**** db reqs
***** sources
#+begin_src sqlite :db db.db
select * from sources;
#+end_src

#+RESULTS:
| 9 | default | joegame.org |
***** images
#+begin_src sqlite :db db.db :header on
select images.name,imagesmeta.id,imagesmeta.source,images.hash from imagesmeta join images on images.id=imagesmeta.id order by random() limit 12;
#+end_src

#+RESULTS:
| name                                     |    id | source | hash                                                             |
| ME_Singles_Camping_32x32_Tree_251.png    |  8618 |      9 | fe14fe4d867a739959e8fb7f21553b10d246b3831d2fd53bf1b1d355f349e70f |
| rank054.png                              | 51411 |      9 | a59bf79a16359ce4c638c003635ea69db2fe756eecd0ecd46516932578c3bd31 |
| tileN.png                                | 47901 |      9 | 03995b8d736180b60264e5487f913e4a7952931e657262615ed84adc37f84aee |
| tile_0063.png                            | 28937 |      9 | 11195882f40a840cca2e16fca3812bdc4dd729ccc661770206ba97d046afde48 |
| ME_Singles_Garden_16x16_Fountain_1_3.png |  6611 |      9 | de17bfe76897505901179695b38b49701631dbb9e9d76992c59e2c92ec1971e8 |
| emote_stars.png                          | 26260 |      9 | b2907fb91e64a6ac5c33dd789d8a2dbc58542f99eec4cdaa05bcf9b3d2eab598 |
| man_point.png                            | 33094 |      9 | 2bc764307eeba301bc828b0e764e53f3a0f2213133bf2881b52c4ffaf92db616 |
| ME_Singles_Camping_32x32_Tree_13.png     |  8934 |      9 | 8e8a17052b6fe0cc601e129a41923c4b9be12c4cbf0248a919eb0f773853e9b2 |
| emote_alert.png                          | 26000 |      9 | 1e34bc727cf5b823d6b4b2c6fa26df897658056389cca6b623f668d2e31d6593 |
| tag_8.png                                | 45182 |      9 | 4d7d4098df4979a9824d7847dd92c8a29ca43ac8fbd543d53a02c4fab825ec58 |
| monkey.png                               | 45592 |      9 | fdbe1a404dfea9fdb7d8a353773ef774d6c3e37e0919d4a2a9a20317304ed49a |
| elementStone015.png                      | 37552 |      9 | 430fc1e80328866181144d90a5223941b217b0c02e7a42d6eb9e772f008ab4bd |
***** objects

#+begin_src sqlite :db db.db
INSERT INTO objects(image,name,tiles,tilesWidth) values (123, 'testobject', '[1, 2, 3, 4, 5, 6]', 2)
#+end_src

#+begin_src sqlite :db db.db
SELECT json(tiles), name, tilesWidth from objects limit 2;
#+end_src

#+RESULTS:
| [1,2,3,4,5,6] | testobject | 2 |
**** bootstram
#+begin_src lisp :package asset-db
(insert-images-from-dir-source "/home/mik/joegame/assets/images/bin/FungusCave-limezu/" "limezu -- https://limezu.itch.io/")
(insert-images-from-dir-source "/home/mik/joegame/assets/images/bin/Modern_Exteriors/" "limezu -- https://limezu.itch.io/")
(insert-images-from-dir-source "/home/mik/joegame/assets/images/bin/Modern_Office_Revamped_v1.1-limezu/" "limezu -- https://limezu.itch.io/")
#+end_src
** <2024-07-22 Mon>
*** api?
The de jure main view can be described at a certain scale as a width and height at 25600, and x,y offset both at -2400.  then applying scales can just take this into account. E.g, at 1/16 the whole world view is of size 25600/16 and offset -2400/16.

The world library in general should have a simple external api:
- =*worldconf*= which can define the signal.
- =world-pic x y w h scale &optional threads=
- =world-map x y w h=
*** performance, moving params to hash table
** <2024-07-23 Tue>
With measurements above,
#+begin_src lisp
(time (worldconf::full-world-pic-file 1/16 "full-pic.png"))
;; Evaluation took:
;; 155.975 seconds of real time
;; 154.486909 seconds of total run time (154.462772 user, 0.024137 system)
;; [ Real times consist of 0.174 seconds GC time, and 155.801 seconds non-GC time. ]
;; [ Run times consist of 0.463 seconds GC time, and 154.024 seconds non-GC time. ]
;; 99.05% CPU
;; 329,419,757,396 processor cycles
;; 4,246,619,024 bytes consed
#+end_src
With most of the time on the noise ffi.  going to try and speed that up with new noise.

Fastnoiselite takes a pointer to a state struct object, but can handle various domain types and

Looking at router-filter logic [[file:worldconf-utils.lisp::defmethod get-val ((f router-filter) (p point)][here]]... Why does this work? Ultimately at the point of going over actual worldconf DSL at the moment, to make it work with long-running perlin instances.  Will also only be considering areas at this point, perhaps that is all the granularity we need after all.

One more time from the top:

A signal has a value at an x,y. This chooses one of its children.

A filter has a signal or other filter as its source. It has a value, and chooses the children of the ultimate source.

*** on worldconf changes
Right now, a signal simply chooses a child and lets the child do what it will, there is no sharing the value... The complexity of stretch and others makes it hard to see what is going on.

Solution: build into the child-choosing a user defined selection.

#+begin_src lisp
(perlin~ (...)
         :children
         ((0.1 . (__ :shore))
         (0.3 . (__ :late-shore))
         ...etc
         )
#+end_src

Further, make subgroups a thing which automatically subdivide the inner value

#+begin_src lisp
(perlin~ (...)
         :children
         ((0.1 . (__ :shore))
         (0.3 . (__ :late-shore))
         (0.7 . ((0.3 . (__ :grass))
                 (0.7 . ())))
         ...etc
         )
#+end_src

Should remove the need for many of the conf complexities.

Another change should be starting from starts not ends.
#+begin_src lisp
(perlin~ (...)
         :children
         ((0.0 . (__ :shore))
         (0.3 . (__ :late-shore))
         ...etc
         )
#+end_src

Should mean :shore from 0.0 to < 0.3, and 0.3 up is late-shore


#+begin_src lisp :package :worldconf
(require 'sb-sprof)
(sb-sprof:with-profiling (:max-samples 1000
                          :report :flat
                          :loop nil) (worldconf::full-world-pic-file 1/128 "tt.png"))
#+end_src

#+RESULTS:
: T
